{"version":3,"sources":["map2D.ts","GameOfLife/GameOfLife.tsx","Maze/Maze.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["map2D","grid2D","callback","map","col","y","element","x","GameOfLife","useState","Array","e","fill","grid","setGrid","playing","setPlaying","generationCount","setGenerationCount","useEffect","isCellAliveNextGeneration","cellX","cellY","aliveNeighbourCount","dx","dy","filter","length","intervalHandle","setInterval","alive","clearInterval","className","style","gridTemplateColumns","gridTemplateRows","onClick","newGrid","disabled","generateEmptyMaze","rows","cols","newCell","edges","top","bottom","right","left","visited","state","distance","Infinity","coordsEqual","A","B","getUnvisitedNeighbourIdxs","coords","maze","cell","diffs","push","Maze","setMaze","active","setActive","delay","setDelay","pathPoints","setPathPoints","timer","useRef","Promise","res","setTimeout","current","generateMaze","a","newMaze","stack","curr","pop","unvisitedNeighboursIdxs","nextCell","Math","floor","random","solveMaze","alert","currentCoords","neighbourIdxs","neighbour","newDistance","distanceToSet","min","minCoords","console","log","getOpacityFromDistance","opacity","getCellColor","cellState","error","coordsAtA","coordsAtB","pickPathPoint","ReactSlider","invert","max","onChange","value","thumbClassName","trackClassName","Headline","text","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"gNAAO,SAASA,EACdC,EACAC,GAEA,OAAOD,EAAOE,KAAI,SAACC,EAAKC,GAAN,OAChBD,EAAID,KAAI,SAACG,EAASC,GAAV,OAAgBL,EAASI,EAAS,CAACC,EAAGF,U,WCkInCG,EAlII,WACjB,IACA,EAAwBC,mBACtB,YAAIC,MAFoB,KAEPP,KAAI,SAACQ,GAAD,OAAOD,MAFR,IAEoBE,MAAK,OAD/C,mBAAOC,EAAP,KAAaC,EAAb,KAGA,EAA8BL,oBAAS,GAAvC,mBAAOM,EAAP,KAAgBC,EAAhB,KACA,EAA8CP,mBAAS,GAAvD,mBAAOQ,EAAP,KAAwBC,EAAxB,KAEAC,qBAAU,WACR,IAqBMC,EAA4B,SAACb,EAAWF,GAC5C,IArBAgB,EACAC,EAoBMC,GArBNF,EAqBuDd,EApBvDe,EAoB0DjB,EAjB5C,CACZ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,CAAC,GAAI,GACL,EAAE,GAAI,GACN,EAAE,EAAG,GACL,EAAE,EAAG,IAEJF,KAAI,mCAAEqB,EAAF,KAAMC,EAAN,WAAc,CAACJ,EAAQG,EAAIF,EAAQG,MACvCC,QAAO,mCAAEnB,EAAF,KAAKF,EAAL,YAAY,GAAKE,GAAKA,EAxBV,IAwBsB,GAAKF,GAAKA,EAxBpC,MAyBfqB,QAAO,mCAAEnB,EAAF,KAAKF,EAAL,YAAYQ,EAAKR,GAAGE,MACjBoB,QAQb,OAAKd,EAAKR,GAAGE,IAKkB,IAAxBgB,GALyC,IAAxBA,GAoBpBK,EAAiBC,uBAAY,WAX7Bd,IACFD,EACEd,EAAMa,GAAM,SAACiB,EAAD,0BAASvB,EAAT,KAAYF,EAAZ,YACVe,EAA0Bb,EAAGF,OAGjCa,EAAmBD,EAAkB,MAIxB,KAGjB,OAAO,WACLc,wBAAcH,MAEf,CA3DuB,GA2DhBX,EAAiBJ,EAAME,EA3DX,KAmEtB,OACE,gCACE,qBAAKiB,UAAU,YAAf,SACE,qBACEA,UAAU,+CACVC,MAAO,CACLC,oBAAoB,UAAD,OAzEH,GAyEG,UACnBC,iBAAiB,UAAD,OA1EJ,GA0EI,WAJpB,SAOGnC,EAAMa,GAAM,SAACiB,EAAD,0BAASvB,EAAT,KAAYF,EAAZ,YACX,qBACE2B,UAAS,8BACPF,EAAQ,cAAgB,YAG1BM,QAAS,WACP,IAAMC,EAAUxB,EAChBwB,EAAQhC,GAAGE,IAAMuB,EACjBhB,EAAQ,YAAIuB,MARhB,UAIU9B,EAJV,YAIeF,WAUrB,8BAeE,sBAAK2B,UAAU,2BAAf,UACE,wBACEA,UAAU,oCACVM,UAAU,EACVF,QAAS,kBAAMpB,GAAYD,IAH7B,SAKGA,EAAU,QAAU,SAEvB,qBAAKiB,UAAU,8BAAf,SAA8Cf,IAC9C,wBACEe,UAAU,qCACVM,UAAU,EACVF,QAAS,kBAzDjBtB,EAAQd,EAAMa,GAAM,SAACiB,GAAD,OAAW,MAC/BZ,EAAmB,QACnBF,GAAW,IAoDL,4B,+CCzGJuB,EAAoB,SAACC,EAAcC,GAGvC,IAFA,IAAM5B,EAAO,YAAIH,MAAM8B,IAAOrC,KAAI,SAACQ,GAAD,OAAOD,MAAM+B,MAEtClC,EAAI,EAAGA,EAAIM,EAAKc,OAAQpB,IAC/B,IAAK,IAAIF,EAAI,EAAGA,EAAIQ,EAAK,GAAGc,OAAQtB,IAAK,CACvC,IAAMqC,EAAU,CACdC,MAAO,CAAEC,KAAK,EAAMC,QAAQ,EAAMC,OAAO,EAAMC,MAAM,GACrDC,SAAS,EACTC,MAAO,UACPC,SAAUC,KAEZtC,EAAKN,GAAGF,GAAKqC,EAGjB,OAAO7B,GAIHuC,EAAc,SAACC,EAAWC,GAAZ,OAA0BD,EAAE9C,IAAM+C,EAAE/C,GAAK8C,EAAEhD,IAAMiD,EAAEjD,GACjEkD,EAA4B,SAChCC,EACAC,EACAC,GAEA,IAAIC,EAAQ,CACV,CAAEnC,GAAI,EAAGC,GAAI,GACb,CAAED,GAAI,EAAGC,GAAI,GACb,CAAED,GAAI,EAAGC,IAAK,GACd,CAAED,IAAK,EAAGC,GAAI,IAkBhB,OAfIiC,IACFC,EAAQ,GACHD,EAAKf,MAAMC,KAAKe,EAAMC,KAAK,CAAEpC,GAAI,EAAGC,IAAK,IACzCiC,EAAKf,MAAME,QAAQc,EAAMC,KAAK,CAAEpC,GAAI,EAAGC,GAAI,IAC3CiC,EAAKf,MAAMG,OAAOa,EAAMC,KAAK,CAAEpC,GAAI,EAAGC,GAAI,IAC1CiC,EAAKf,MAAMI,MAAMY,EAAMC,KAAK,CAAEpC,IAAK,EAAGC,GAAI,KAG1BkC,EACpBxD,KAAI,gBAAGqB,EAAH,EAAGA,GAAIC,EAAP,EAAOA,GAAP,MAAiB,CAAElB,EAAGiD,EAAOjD,EAAIiB,EAAInB,EAAGmD,EAAOnD,EAAIoB,MACvDC,QACC,gBAAGnB,EAAH,EAAGA,EAAGF,EAAN,EAAMA,EAAN,OAAc,GAAKE,GAAKA,EAAIkD,EAAK,GAAG9B,QAAU,GAAKtB,GAAKA,EAAIoD,EAAK9B,UAElED,QAAO,SAAC8B,GAAD,OAAaC,EAAKD,EAAOnD,GAAGmD,EAAOjD,GAAGyC,YAwSnCa,EAnSF,WACX,IAEA,EAAwBpD,mBAAmB8B,EAF9B,GACA,KACb,mBAAOkB,EAAP,KAAaK,EAAb,KACA,EAA4BrD,oBAAS,GAArC,mBAAOsD,EAAP,KAAeC,EAAf,KACA,EAA0BvD,mBAAS,KAAnC,mBAAOwD,EAAP,KAAcC,EAAd,KAGA,EAAoCzD,mBAAqB,CACvD4C,EAAG,KACHC,EAAG,OAFL,mBAAOa,EAAP,KAAmBC,EAAnB,KAoBMC,EAAQC,kBAAO,kBAAM,IAAIC,SAAQ,SAACC,GAAD,OAASC,WAAWD,EAAKP,SAChE9C,qBAAU,WACRkD,EAAMK,QAAU,kBAAM,IAAIH,SAAQ,SAACC,GAAD,OAASC,WAAWD,EAAKP,SAC1D,CAACA,IAEJ,IAAMU,EAAY,uCAAG,oCAAAC,EAAA,sDAEnBZ,GAAU,GAEJa,EAAUtC,EApCL,GACA,IAoCLuC,EAAkB,GAGxBD,GADIE,EAA2B,CAAExE,EAAG,EAAGF,EAAG,IAC7BA,GAAG0E,EAAKxE,GAAGyC,SAAU,EAClC6B,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAG0C,MAAQ,SAEhC6B,EAAMlB,KAAKmB,GAXQ,UAcjBjB,EAAQ,YAAIe,MAERZ,EAAQ,GAhBK,kCAgBII,EAAMK,UAhBV,WAkBjBG,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAG0C,MAAQ,UAChC8B,EAAOD,EAAME,MAnBI,qDAsBjBH,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAG0C,MAAQ,UAE1BgC,EAA0B1B,EAA0BwB,EAAMF,IACpClD,OAAS,IACnCmD,EAAMlB,KAAKmB,IAELG,EACJD,EACEE,KAAKC,MAAMD,KAAKE,SAAWJ,EAAwBtD,UAI1CpB,EAAIwE,EAAKxE,GACpBsE,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAGoC,MAAMG,OAAQ,EACtC+B,EAAQK,EAAS7E,GAAG6E,EAAS3E,GAAGoC,MAAMI,MAAO,GACpCmC,EAAS3E,EAAIwE,EAAKxE,GAC3BsE,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAGoC,MAAMI,MAAO,EACrC8B,EAAQK,EAAS7E,GAAG6E,EAAS3E,GAAGoC,MAAMG,OAAQ,GACrCoC,EAAS7E,EAAI0E,EAAK1E,GAC3BwE,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAGoC,MAAME,QAAS,EACvCgC,EAAQK,EAAS7E,GAAG6E,EAAS3E,GAAGoC,MAAMC,KAAM,GACnCsC,EAAS7E,EAAI0E,EAAK1E,IAC3BwE,EAAQE,EAAK1E,GAAG0E,EAAKxE,GAAGoC,MAAMC,KAAM,EACpCiC,EAAQK,EAAS7E,GAAG6E,EAAS3E,GAAGoC,MAAME,QAAS,GAEjDgC,EAAQK,EAAS7E,GAAG6E,EAAS3E,GAAGyC,SAAU,EAE1C8B,EAAMlB,KAAKsB,IAjDI,uBAqDnBpB,EACE9D,EAAM6E,GAAS,SAACnB,GAAD,mBAAC,eACXA,GADU,IAEbV,SAAS,EACTC,MAAO,gBAGXe,GAAU,GA5DS,4CAAH,qDA+DZsB,EAAS,uCAAG,oEAAAV,EAAA,yDAERvB,EAASc,EAATd,EAAGC,EAAMa,EAANb,EACND,GAAMC,EAHK,yCAKPiC,MAAM,4DALC,OAOhBvB,GAAU,GACNa,EAAU7E,EAAMyD,GAAM,SAACC,GAAD,mBAAC,eACtBA,GADqB,IAExBV,SAAS,EACTE,SAAUC,IACVF,MAAO,eAGTa,EAAQ,YAAIe,IAGZA,GADIW,EAAgBnC,GACEhD,GAAGmF,EAAcjF,GAAG2C,SAAW,EAlBrC,YAqBVe,EAAQ,GArBE,kCAqBOI,EAAMK,UArBb,QAsBRe,EAAgBlC,EACpBiC,EACAX,EACAA,EAAQW,EAAcnF,GAAGmF,EAAcjF,IAzB3B,cA6BOkF,GA7BP,IA6Bd,2BAAWjC,EAAyB,QAC5BkC,EAAYb,EAAQrB,EAAOnD,GAAGmD,EAAOjD,GACrCoF,EACJd,EAAQW,EAAcnF,GAAGmF,EAAcjF,GAAG2C,SAAW,EACjD0C,EACJF,EAAUxC,SAAWyC,EAAcD,EAAUxC,SAAWyC,EAE1Dd,EAAQrB,EAAOnD,GAAGmD,EAAOjD,GAAG2C,SAAW0C,EApC3B,8BA0Cd,IAJAf,EAAQW,EAAcnF,GAAGmF,EAAcjF,GAAGyC,SAAU,EAEhD6C,EAAM1C,IACN2C,EAAoB,CAAEvF,GAAI,EAAGF,GAAI,GAC5BE,EAAI,EAAGA,EAxIP,GAwIiBA,IACxB,IAASF,EAAI,EAAGA,EA1IT,GA0ImBA,KACnBwE,EAAQxE,GAAGE,GAAGyC,SAAW6B,EAAQxE,GAAGE,GAAG2C,SAAW2C,IACrDA,EAAMhB,EAAQxE,GAAGE,GAAG2C,SACpB4C,EAAY,CAAEvF,IAAGF,MA9CT,GAmDdmF,EAAgBM,EAEhBhC,EAAQ,YAAIe,KAERzB,EAAYoC,EAAelC,GAvDjB,4EA0DhBuB,EAAU7E,EAAM6E,GAAS,SAACnB,GAAD,mBAAC,eACrBA,GADoB,IAEvBV,SAAS,OAGXc,EAAQe,GAERb,GAAU,GAjEM,WAkERZ,EAAYoC,EAAenC,GAlEnB,sBAmEVY,EAAQ,GAnEE,kCAmEOI,EAAMK,UAnEb,QAqERe,EAAgBlC,EACpBiC,EACAX,EACAA,EAAQW,EAAcnF,GAAGmF,EAAcjF,IAErCsF,EAAM1C,IACN2C,EAAoB,CAAEvF,GAAI,EAAGF,GAAI,GA3EvB,cA4EKoF,GA5EL,IA4Ed,2BAASjC,EAAyB,QAChCuC,QAAQC,IAAInB,EAAQrB,EAAOnD,GAAGmD,EAAOjD,IACjCsE,EAAQrB,EAAOnD,GAAGmD,EAAOjD,GAAG2C,SAAW2C,IACzCA,EAAMhB,EAAQrB,EAAOnD,GAAGmD,EAAOjD,GAAG2C,SAClC4C,EAAYtC,GAhFF,8BAqFdqB,GADAW,EAAgBM,GACMzF,GAAGmF,EAAcjF,GAAG0C,MAAQ,SAClDa,EAAQ,YAAIe,IAtFE,4DAAH,qDAyFToB,EAAyB,SAAC/C,GAC9B,GAAIA,IAAaC,IAAU,OAAO,EAClC,IACM+C,GADwB1D,IACUU,GADVV,IAE9B,OAAO0D,EAAU,GAAM,GAAMA,GAGzBC,EAAe,SAACC,EAAsB5C,GAC1C,GACGW,EAAWd,GAAKD,EAAYI,EAAQW,EAAWd,IAC/Cc,EAAWb,GAAKF,EAAYI,EAAQW,EAAWb,GAEhD,MAAO,eAET,GAAIS,GAAUN,EAAKD,EAAOnD,GAAGmD,EAAOjD,GAAG2C,WAAaC,IAClD,MAAO,cAET,OAAQiD,GACN,IAAK,SACH,MAAO,cACT,IAAK,UACH,MAAO,cACT,IAAK,UACH,MAAO,WACT,QAEE,OADAL,QAAQM,MAAM,wBACP,aAIb,OACE,gCACE,qBAAKrE,UAAU,YAAf,SACE,qBACEA,UAAU,wDACVC,MAAO,CACLC,oBAAoB,UAAD,OA3NhB,GA2NgB,UACnBC,iBAAiB,UAAD,OA7Nb,GA6Na,WAJpB,SAOGnC,EAAMyD,GAAM,SAACC,EAAD,0BAAQnD,EAAR,KAAWF,EAAX,YACX,qBACE2B,UAAS,oGAIX0B,EAAKf,MAAMC,KAAO,WAJP,wBAKXc,EAAKf,MAAME,QAAU,WALV,wBAMXa,EAAKf,MAAMG,OAAS,WANT,wBAOXY,EAAKf,MAAMI,MAAQ,WAPR,wBAQXoD,EAAazC,EAAKT,MAAO,CAAE1C,IAAGF,OAC5B4B,MAAO,CACLiE,QAASnC,EAASkC,EAAuBvC,EAAKR,UAAY,GAG5Dd,QAAS,YAnOC,SAACoB,GACrB,IAAQH,EAASc,EAATd,EAAGC,EAAMa,EAANb,EAELgD,EAAYjD,GAAKD,EAAYI,EAAQH,GACrCkD,EAAYjD,GAAKF,EAAYI,EAAQF,GAEvCgD,GAAaC,EAAkBnC,EAAc,CAAEf,EAAG,KAAMC,EAAG,OAE3DgD,EAAkBlC,EAAc,CAAEf,EAAG,KAAMC,MAC3CiD,EAAkBnC,EAAc,CAAEf,IAAGC,EAAG,OAEvCD,EACAC,GAAUc,EAAc,CAAEf,IAAGC,EAAGE,IADtBY,EAAc,CAAEf,EAAGG,EAAQF,MAyN9BkD,CAAc,CAAEjG,IAAGF,MACnB0F,QAAQC,IAAIzF,EAAGF,IAhBnB,SAmBE,sBAAK2B,UAAU,qCAAf,UACGmC,EAAWd,GAAKD,EAAY,CAAE7C,IAAGF,KAAK8D,EAAWd,IAAM,IACvDc,EAAWb,GAAKF,EAAY,CAAE7C,IAAGF,KAAK8D,EAAWb,IAAM,QArB5D,UAaU/C,EAbV,YAaeF,WAgBrB,gCACE,sBAAK2B,UAAU,yCAAf,UACE,qBAAKA,UAAU,0BAAf,oBACA,cAACyE,EAAA,EAAD,CACEC,QAAQ,EACRb,IAAK,EACLc,IAAK,IACLC,SAAU1C,EACV2C,MAAO5C,EACPjC,UAAU,iBACV8E,eAAe,2DACfC,eAAe,iCAInB,sBAAK/E,UAAU,4BAAf,UACE,wBACEA,UAAU,qBACVM,SAAUyB,EACV3B,QAAS,kBAAMuC,KAHjB,sBAOA,wBACE3C,UAAU,qBACVM,SAAUyB,EACV3B,QAAS,kBAAMkD,KAHjB,6BCnVJ0B,EAAW,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAH,OACf,oBAAIjF,UAAU,mDAAd,SAAkEiF,KA2BrDC,MAxBf,WACE,OACE,sBAAKlF,UAAU,oEAAf,UACE,qBAAKA,UAAU,mEAAf,SACE,oBAAIA,UAAU,uCAAd,mCAGF,sBAAKA,UAAU,8DAAf,UACE,cAAC,EAAD,CAAUiF,KAAK,SACf,qBAAKjF,UAAU,iDAAf,SACE,cAAC,EAAD,SAIJ,sBAAKA,UAAU,qDAAf,UACE,cAAC,EAAD,CAAUiF,KAAK,iBACf,qBAAKjF,UAAU,gDAAf,SACE,cAAC,EAAD,aCdUmF,QACW,cAA7BC,OAAOC,SAASC,UAEa,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZJC,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,SDqI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAA7B,GACLN,QAAQM,MAAMA,EAAM8B,c","file":"static/js/main.a791597d.chunk.js","sourcesContent":["export function map2D<T>(\n  grid2D: T[][],\n  callback: (element: T, coords: [x: number, y: number]) => unknown\n) {\n  return grid2D.map((col, y) =>\n    col.map((element, x) => callback(element, [x, y]))\n  );\n}\n","import { useEffect, useState } from \"react\";\n// import ReactSlider from \"react-slider\";\nimport { setInterval, clearInterval } from \"timers\";\nimport { map2D } from \"../map2D\";\n\nconst GameOfLife = () => {\n  const [rows, cols] = [20, 20];\n  const [grid, setGrid] = useState<boolean[][]>(\n    [...Array(cols)].map((e) => Array(rows).fill(false))\n  );\n  const [playing, setPlaying] = useState(false);\n  const [generationCount, setGenerationCount] = useState(0);\n\n  useEffect(() => {\n    const getCellAliveNeighbourCount = (\n      cellX: number,\n      cellY: number\n    ): number => {\n      //TODO opitmize by adding empty row and col on each edge\n      const diffs = [\n        [0, 1],\n        [1, 1],\n        [1, 0],\n        [1, -1],\n        [0, -1],\n        [-1, -1],\n        [-1, 0],\n        [-1, 1],\n      ]\n        .map(([dx, dy]) => [cellX + dx, cellY + dy]) //calculate position of potential neighbours\n        .filter(([x, y]) => 0 <= x && x < cols && 0 <= y && y < rows) //filter cells out of bounds\n        .filter(([x, y]) => grid[y][x]); //filter only for alive cells\n      return diffs.length;\n    };\n\n    const isCellAliveNextGeneration = (x: number, y: number) => {\n      const aliveNeighbourCount = getCellAliveNeighbourCount(x, y);\n\n      //if a cell is dead and has exactly 3 neighbours it becomes alive\n      //otherwise it remains dead\n      if (!grid[y][x]) return aliveNeighbourCount === 3;\n\n      //here we are sure the cell is alive\n      //if it has 2 or 3 neighbours it lives on\n      //otherwise it dies of over/under population\n      return aliveNeighbourCount === 2 || aliveNeighbourCount === 3;\n    };\n\n    const nextGeneration = () => {\n      if (playing) {\n        setGrid(\n          map2D(grid, (alive, [x, y]) =>\n            isCellAliveNextGeneration(x, y)\n          ) as boolean[][]\n        );\n        setGenerationCount(generationCount + 1);\n      }\n    };\n\n    const interval = 1000;\n    const intervalHandle = setInterval(() => nextGeneration(), interval);\n\n    return () => {\n      clearInterval(intervalHandle);\n    };\n  }, [cols, generationCount, grid, playing, rows]);\n\n  const clearBoard = () => {\n    setGrid(map2D(grid, (alive) => false) as boolean[][]);\n    setGenerationCount(0);\n    setPlaying(false);\n  };\n\n  return (\n    <div>\n      <div className=\"square-70\">\n        <div\n          className=\"grid gap-0 w-full h-full place-items-stretch\"\n          style={{\n            gridTemplateColumns: `repeat(${cols}, 1fr)`,\n            gridTemplateRows: `repeat(${rows}, 1fr)`,\n          }}\n        >\n          {map2D(grid, (alive, [x, y]) => (\n            <div\n              className={`border border-black ${\n                alive ? \"bg-blue-400\" : \"bg-white\"\n              }`}\n              key={`${x}-${y}`}\n              onClick={() => {\n                const newGrid = grid;\n                newGrid[y][x] = !alive;\n                setGrid([...newGrid]);\n              }}\n            />\n          ))}\n        </div>\n      </div>\n      <div>\n        {/* <div className=\"flex justify-between my-2 items-center\">\n          <div className=\"text-white text-xl mr-2\">speed:</div>\n          <ReactSlider\n            invert={true}\n            min={0}\n            max={200}\n            onChange={() => {}}\n            value={2}\n            className=\"mx-auto w-full\"\n            thumbClassName=\"w-5 h-5 transform -translate-y-2  bg-white rounded-full \"\n            trackClassName=\"h-1 bg-white rounded-full\"\n          />\n        </div> */}\n\n        <div className=\"py-2 flex justify-center\">\n          <button\n            className=\"w-20 text-left text-white text-xl\"\n            disabled={false}\n            onClick={() => setPlaying(!playing)}\n          >\n            {playing ? \"pause\" : \"play\"}\n          </button>\n          <div className=\"text-white text-2xl mx-auto\">{generationCount}</div>\n          <button\n            className=\"w-20 text-right text-white text-xl\"\n            disabled={false}\n            onClick={() => clearBoard()}\n          >\n            clear\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default GameOfLife;\n","import { useEffect, useRef, useState } from \"react\";\nimport ReactSlider from \"react-slider\";\nimport { map2D } from \"../map2D\";\n\ntype CellState = \"active\" | \"visited\" | \"default\";\ntype Cell = {\n  edges: {\n    top: boolean;\n    right: boolean;\n    bottom: boolean;\n    left: boolean;\n  };\n  visited: boolean;\n  distance: number;\n  state: CellState;\n};\n\nconst generateEmptyMaze = (rows: number, cols: number): Cell[][] => {\n  const grid = [...Array(rows)].map((e) => Array(cols));\n\n  for (let x = 0; x < grid.length; x++) {\n    for (let y = 0; y < grid[0].length; y++) {\n      const newCell = {\n        edges: { top: true, bottom: true, right: true, left: true },\n        visited: false,\n        state: \"default\",\n        distance: Infinity,\n      };\n      grid[x][y] = newCell;\n    }\n  }\n  return grid;\n};\n\ntype Coords = { x: number; y: number };\nconst coordsEqual = (A: Coords, B: Coords) => A.x === B.x && A.y === B.y;\nconst getUnvisitedNeighbourIdxs = (\n  coords: Coords,\n  maze: Cell[][],\n  cell?: Cell\n): Coords[] => {\n  let diffs = [\n    { dx: 0, dy: 1 },\n    { dx: 1, dy: 0 },\n    { dx: 0, dy: -1 },\n    { dx: -1, dy: 0 },\n  ];\n\n  if (cell) {\n    diffs = [];\n    if (!cell.edges.top) diffs.push({ dx: 0, dy: -1 });\n    if (!cell.edges.bottom) diffs.push({ dx: 0, dy: 1 });\n    if (!cell.edges.right) diffs.push({ dx: 1, dy: 0 });\n    if (!cell.edges.left) diffs.push({ dx: -1, dy: 0 });\n  }\n\n  const neighboursIdxs = diffs\n    .map(({ dx, dy }) => ({ x: coords.x + dx, y: coords.y + dy })) //calculate position of potential neighbours\n    .filter(\n      ({ x, y }) => 0 <= x && x < maze[0].length && 0 <= y && y < maze.length\n    ) //filter cells out of bounds\n    .filter((coords) => !maze[coords.y][coords.x].visited);\n\n  return neighboursIdxs;\n};\n\nconst Maze = () => {\n  const rows = 20;\n  const cols = 20;\n  const [maze, setMaze] = useState<Cell[][]>(generateEmptyMaze(rows, cols));\n  const [active, setActive] = useState(false);\n  const [delay, setDelay] = useState(100); // ms\n\n  type PathPoints = { A: Coords | null; B: Coords | null };\n  const [pathPoints, setPathPoints] = useState<PathPoints>({\n    A: null,\n    B: null,\n  });\n\n  const pickPathPoint = (coords: Coords): void => {\n    const { A, B } = pathPoints;\n\n    const coordsAtA = A && coordsEqual(coords, A);\n    const coordsAtB = B && coordsEqual(coords, B);\n\n    if (coordsAtA && coordsAtB) return setPathPoints({ A: null, B: null });\n\n    if (coordsAtA) return setPathPoints({ A: null, B });\n    if (coordsAtB) return setPathPoints({ A, B: null });\n\n    if (!A) return setPathPoints({ A: coords, B });\n    if (!B) return setPathPoints({ A, B: coords });\n  };\n\n  const timer = useRef(() => new Promise((res) => setTimeout(res, delay)));\n  useEffect(() => {\n    timer.current = () => new Promise((res) => setTimeout(res, delay));\n  }, [delay]);\n\n  const generateMaze = async () => {\n    //randomized DFS algorithm\n    setActive(true);\n\n    const newMaze = generateEmptyMaze(rows, cols);\n    const stack: Coords[] = [];\n\n    let curr: Coords | undefined = { x: 0, y: 0 };\n    newMaze[curr.y][curr.x].visited = true;\n    newMaze[curr.y][curr.x].state = \"active\";\n\n    stack.push(curr);\n\n    while (true) {\n      setMaze([...newMaze]);\n\n      if (delay > 0) await timer.current();\n\n      newMaze[curr.y][curr.x].state = \"visited\";\n      curr = stack.pop();\n      if (!curr) break;\n\n      newMaze[curr.y][curr.x].state = \"active\";\n\n      const unvisitedNeighboursIdxs = getUnvisitedNeighbourIdxs(curr, newMaze);\n      if (unvisitedNeighboursIdxs.length > 0) {\n        stack.push(curr);\n\n        const nextCell =\n          unvisitedNeighboursIdxs[\n            Math.floor(Math.random() * unvisitedNeighboursIdxs.length)\n          ];\n\n        //probably could be more compact an nicer but im leaving this as is\n        if (nextCell.x > curr.x) {\n          newMaze[curr.y][curr.x].edges.right = false;\n          newMaze[nextCell.y][nextCell.x].edges.left = false;\n        } else if (nextCell.x < curr.x) {\n          newMaze[curr.y][curr.x].edges.left = false;\n          newMaze[nextCell.y][nextCell.x].edges.right = false;\n        } else if (nextCell.y > curr.y) {\n          newMaze[curr.y][curr.x].edges.bottom = false;\n          newMaze[nextCell.y][nextCell.x].edges.top = false;\n        } else if (nextCell.y < curr.y) {\n          newMaze[curr.y][curr.x].edges.top = false;\n          newMaze[nextCell.y][nextCell.x].edges.bottom = false;\n        }\n        newMaze[nextCell.y][nextCell.x].visited = true;\n\n        stack.push(nextCell);\n      }\n    }\n\n    setMaze(\n      map2D(newMaze, (cell) => ({\n        ...cell,\n        visited: false,\n        state: \"default\",\n      })) as Cell[][]\n    );\n    setActive(false);\n  };\n\n  const solveMaze = async () => {\n    //dijkstra algorithm\n    const { A, B } = pathPoints;\n    if (!A || !B)\n      //TODO make it nicer than alert\n      return alert(\"You have to pick points A and B by clicking on the maze\");\n\n    setActive(true);\n    let newMaze = map2D(maze, (cell) => ({\n      ...cell,\n      visited: false,\n      distance: Infinity,\n      state: \"default\",\n    })) as Cell[][];\n\n    setMaze([...newMaze]);\n\n    let currentCoords = A;\n    newMaze[currentCoords.y][currentCoords.x].distance = 0;\n\n    while (true) {\n      if (delay > 0) await timer.current();\n      const neighbourIdxs = getUnvisitedNeighbourIdxs(\n        currentCoords,\n        newMaze,\n        newMaze[currentCoords.y][currentCoords.x]\n      );\n      // console.log(newMaze[currentCoords.y][currentCoords.x]);\n\n      for (const coords of neighbourIdxs) {\n        const neighbour = newMaze[coords.y][coords.x];\n        const newDistance =\n          newMaze[currentCoords.y][currentCoords.x].distance + 1;\n        const distanceToSet =\n          neighbour.distance < newDistance ? neighbour.distance : newDistance;\n        // console.log(coords, newDistance);\n        newMaze[coords.y][coords.x].distance = distanceToSet;\n      }\n      newMaze[currentCoords.y][currentCoords.x].visited = true;\n\n      let min = Infinity;\n      let minCoords: Coords = { x: -1, y: -1 };\n      for (let x = 0; x < cols; x++) {\n        for (let y = 0; y < rows; y++) {\n          if (!newMaze[y][x].visited && newMaze[y][x].distance < min) {\n            min = newMaze[y][x].distance;\n            minCoords = { x, y };\n          }\n        }\n      }\n\n      currentCoords = minCoords;\n\n      setMaze([...newMaze]);\n\n      if (coordsEqual(currentCoords, B)) break;\n    }\n\n    newMaze = map2D(newMaze, (cell) => ({\n      ...cell,\n      visited: false,\n    })) as Cell[][];\n\n    setMaze(newMaze);\n\n    setActive(false);\n    while (!coordsEqual(currentCoords, A)) {\n      if (delay > 0) await timer.current();\n\n      const neighbourIdxs = getUnvisitedNeighbourIdxs(\n        currentCoords,\n        newMaze,\n        newMaze[currentCoords.y][currentCoords.x]\n      );\n      let min = Infinity;\n      let minCoords: Coords = { x: -1, y: -1 };\n      for (let coords of neighbourIdxs) {\n        console.log(newMaze[coords.y][coords.x]);\n        if (newMaze[coords.y][coords.x].distance < min) {\n          min = newMaze[coords.y][coords.x].distance;\n          minCoords = coords;\n        }\n      }\n\n      currentCoords = minCoords;\n      newMaze[currentCoords.y][currentCoords.x].state = \"active\";\n      setMaze([...newMaze]);\n    }\n  };\n  const getOpacityFromDistance = (distance: number) => {\n    if (distance === Infinity) return 1;\n    const arbitraryMaxDistance = (rows * cols) / 2; //2 was chosen to look good in most cases\n    const opacity = (arbitraryMaxDistance - distance) / arbitraryMaxDistance;\n    return opacity < 0.1 ? 0.1 : opacity;\n  };\n\n  const getCellColor = (cellState: CellState, coords: Coords) => {\n    if (\n      (pathPoints.A && coordsEqual(coords, pathPoints.A)) ||\n      (pathPoints.B && coordsEqual(coords, pathPoints.B))\n    )\n      return \"bg-green-300\";\n\n    if (active && maze[coords.y][coords.x].distance !== Infinity)\n      return \"bg-blue-700\";\n\n    switch (cellState) {\n      case \"active\":\n        return \"bg-pink-300\";\n      case \"visited\":\n        return \"bg-blue-400\";\n      case \"default\":\n        return \"bg-white\";\n      default:\n        console.error(\"undefined cell state\");\n        return \"bg-white\";\n    }\n  };\n\n  return (\n    <div>\n      <div className=\"square-70\">\n        <div\n          className=\"grid gap-0 w-full h-full place-items-stretch bg-white\"\n          style={{\n            gridTemplateColumns: `repeat(${cols}, 1fr)`,\n            gridTemplateRows: `repeat(${rows}, 1fr)`,\n          }}\n        >\n          {map2D(maze, (cell, [x, y]) => (\n            <div\n              className={`\n          border-black\n          hover:bg-yellow-600\n          text-center\n          ${cell.edges.top && \"border-t\"} \n          ${cell.edges.bottom && \"border-b\"} \n          ${cell.edges.right && \"border-r\"} \n          ${cell.edges.left && \"border-l\"} \n          ${getCellColor(cell.state, { x, y })}`}\n              style={{\n                opacity: active ? getOpacityFromDistance(cell.distance) : 1,\n              }}\n              key={`${x}-${y}`}\n              onClick={() => {\n                pickPathPoint({ x, y });\n                console.log(x, y);\n              }}\n            >\n              <div className=\"object-scale-down tracking-tighter\">\n                {pathPoints.A && coordsEqual({ x, y }, pathPoints.A) && \"A\"}\n                {pathPoints.B && coordsEqual({ x, y }, pathPoints.B) && \"B\"}\n                {/* {cell.distance !== Infinity && cell.distance} */}\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div>\n        <div className=\"flex justify-between my-2 items-center\">\n          <div className=\"text-white text-xl mr-2\">speed:</div>\n          <ReactSlider\n            invert={true}\n            min={0}\n            max={200}\n            onChange={setDelay}\n            value={delay}\n            className=\"mx-auto w-full\"\n            thumbClassName=\"w-5 h-5 transform -translate-y-2  bg-white rounded-full \"\n            trackClassName=\"h-1 bg-white rounded-full\"\n          />\n        </div>\n\n        <div className=\"py-2 flex justify-between\">\n          <button\n            className=\"text-white text-xl\"\n            disabled={active}\n            onClick={() => generateMaze()}\n          >\n            generate\n          </button>\n          <button\n            className=\"text-white text-xl\"\n            disabled={active}\n            onClick={() => solveMaze()}\n          >\n            solve\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from \"react\";\nimport GameOfLife from \"./GameOfLife/GameOfLife\";\nimport Maze from \"./Maze/Maze\";\n\ntype HeadlineProps = { text: string };\nconst Headline = ({ text }: HeadlineProps) => (\n  <h1 className=\"w-4/5 mx-auto mb-8 text-6xl font-bold text-white\">{text}</h1>\n);\n\nfunction App() {\n  return (\n    <div className=\"overflow-y-scroll snap snap-y snap-mandatory h-screen bg-pink-300\">\n      <div className=\"grid place-content-center snap-start transform w-full  h-screen \">\n        <h1 className=\"italic font-bold text-7xl text-white\">Jan Czerwi≈Ñski</h1>\n      </div>\n\n      <div className=\"mt-10 snap-start h-screen transform skew-y-3   bg-green-300\">\n        <Headline text=\"Maze\" />\n        <div className=\" grid place-content-center transform -skew-y-3\">\n          <Maze />\n        </div>\n      </div>\n\n      <div className=\"snap-start h-screen transform skew-y-3 bg-blue-300\">\n        <Headline text=\"Game of Life\" />\n        <div className=\"grid place-content-center transform -skew-y-3\">\n          <GameOfLife />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}